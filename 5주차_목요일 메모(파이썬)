5주차_ 목요일 메모 (파이썬)
개요 : vim post_install.sh 로 들어가서 서비스 자동화 스크립트를 짜는 방법




# 1. 모듈(Module)
모듈이란?
² 모듈은 함수나 변수 또는 클래스를 모아 놓은 파일이다.
² 모듈은 다른 파이썬 프로그램에서 불러와 사용할 수 있게끔 만든 파이썬 파일(.py)이
라고도 할 수 있다.
² 다른 사람들이 이미 만들어 놓은 모듈을 사용할 수도 있고 우리가 직접 만들어서 사용
할 수도 있다.
※ 파이썬 확장자 .py로 만든 파이썬 파일은 모두 모듈이다

# 모듈 불러오기(import)
² import는 이미 만들어 놓은 파이썬 모듈을 사용할 수 있게 해주는 명령어이다.
² import는 현재 디렉터리에 있는 파일이나 파이썬 라이브러리가 저장된 디렉터리에
있는 모듈만 불러올 수 있다.
² 파이썬 라이브러리는 파이썬을 설치할 때 자동으로 설치되는 파이썬 모듈을 말한다.
² 파이썬에서 import로 모듈을 가져오면 해당 스크립트 파일이 한 번 실행된다.
² mod1.py 파일에 있는 add 함수를 사용하기 위해서는 모듈 이름 뒤에 "."(도트 연
산자)를 붙이고 함수 이름을 쓰면 된다.
~~~
def add_func1(a,b):
    c = a + b
    return c
def add_func2(a,b):
    c = a - b
    return c
a= 31
b= 23
print(add_func1(5,6))
print(add_func2(5,6)) 				라는 module2.py가 있다. 
						module3.py에서 새로생성하면 된다.
Import module2   만 입력하여 실행.
이때  모듈이름에 .py를 붙이지 않게 주의한다.


if __name__ == "__main__": 의 의미
1. __name__ 변수란?				( _ _ 언더바 두번 )
² 파이썬의 __name__ 변수는 파이썬이 내부적으로 사용하는 특별한 변수 이름이다.
² 모듈의 이름을 담고 있는 내장 변수이다.
² __name__은 모듈의 이름이 저장되는 변수이며 import로 모듈을 가져왔을 때 모듈의
이름이 저장된다.
² 파이썬 인터프리터로 스크립트 파일을 직접 실행했을 때는 모듈의 이름이 아니라
__name__변수에 '__main__'이 저장된다.
예제) python.py 라는 파일이 있다면 __name__는 python이 되는 것이다.

2. __main__이란?
² 최상위 코드가 실행되는 진입점, 프로그램 시작점을 '엔트리포인트(Entry Point)'라고
한다.
² __name__ 은 표준 입력, 스크립트 또는 대화식 프롬프트에서 읽힐 때 '__main__' 으
로 설정된다.
² __name__의 값을 검사해서 메인 영역에서 실행 중인지 확인이 가능하다는 것이다.
예제)

hello.py 파일
 def hi_func():
     print('반가워요')

# 모듈을 직접 실행할 때만 실행되도록 조건 추가
if __name__ == '__main__':
    print('Hello 모듈 시작')
    print('hello.py __name__:', __name__) 
    print('Hello 모듈 끝')
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
main8.py 파일
	import hello  # hello.py 모듈을 임포트합니다.
#print('main8.py __name__:', __name__) # __name__ 변수 출력
	hello.hi_func()  # hello 모듈 내의 hi_func 함수를 호출합니다.
====================================================
# 예외 처리(try, except)

try:
    # 사용자로부터 두 개의 숫자를 입력받음
    num1 = int(input("첫 번째 숫자를 입력하세요: "))
    num2 = int(input("두 번째 숫자를 입력하세요: "))
    
    # 두 숫자를 나누고 결과를 출력
    result = num1 / num2
    print("나눈 결과:", result)

except ZeroDivisionError:
    # 0으로 나누려고 할 때 발생하는 예외
    print("오류: 0으로 나눌 수 없습니다.")
except ValueError:
    # 정수로 변환할 수 없는 입력을 받았을 때 발생하는 예외
    print("오류: 올바른 숫자를 입력하세요.")
except Exception as e:
    # 다른 모든 예외를 처리하는 범용 예외 처리
    print(f"오류 발생: {e}")
else:
    # 예외가 발생하지 않을 때 실행
    print("나눗셈이 성공적으로 완료되었습니다.")
finally:
    # 항상 실행되는 블록
    print("프로그램 종료")

# 예외 만들기(직접 예외를 만들기)
² 프로그램 수행 도중 특수한 경우에만 예외 처리를 하기 위해서 종종 예외를 만들어서
사용한다.
² 예외는 다음과 같이 파이썬 내장 클래스인 Exception 클래스를 상속하여 만들 수 있
다.
² 오류 메시지를 출력했을 때 오류 메시지가 보이게 하려면 오류 클래스에 __str__ 메
서드를 구현해야 한다.
² __str__ 메서드는 print(e)처럼 오류 메시지를 print문으로 출력할 경우에 호출되는
메서드이다.

list1= [10,20,30,40,50]     

try:  
    for i in range(5):  
        print(list1[i])
except IndexError as e:
    print('인덱스 범위 문제로 일부가 누락됨')
>>>위에서 list1 내에 한 숫자를 지움 > 에러시 print 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 내장 함수

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 2. VMware에서 자동화 스크립트 생성  	(standard in :stdin)
passwd user1 과
[root@server-1 test]# echo '1234' | passwd --stdin  user1	는 같다.

[root@server-1 test]# vim user_create.sh
#!/bin/bash
useradd   user2
passwd     user2
[root@server-1 test]# ll user_create.sh 
-rw-r--r--. 1 root root 48  9월 21 12:15 user_create.sh
[root@server-1 test]# chmod -v a+x user_create.sh 
mode of 'user_create.sh' changed from 0644 (rw-r--r--) to 0755 (rwxr-xr-x)

이후 ./user_create.sh를 입력하면
user2 사용자의 비밀 번호 변경 중 창이 뜬다.
[root@server-1 test]# echo '1234' | passwd --stdin  user1 <<이걸 이용해볼 것이다.

vim u tab 해서 
useradd   user3   
echo '1234' | passwd --stdin user3 		입력하고 저장완료

[root@server-1 test]# tail -3 /etc/shadow	로 확인해보면  user3의 암호가 생성된것을 확인이 가능하다.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# httpd 설치 자동화
[root@server-1 test]# yum remove httpd -y  	로 깔려있으니 삭제한다.

[root@server-1 test]# yum install httpd* -y^C
[root@server-1 test]# systemctl enable --now httpd^C
[root@server-1 test]# firewall-cmd --permanent --add-service=http^C
[root@server-1 test]# firewall-cmd --reload ^C		 	라는 과정을 거쳐야하지만, 단편적인 예로 자동화 스크립트를 만들어보도록 한다.

vim post_install.sh 로 		들어가서
  1 #!/bin/bash
  2 yum install httpd -y
  3 systemctl enable --now httpd
  4 yum install firewall* -y
  5 systemctl enable --now firewalld
  6 
  7 firewall-cmd --permanent --add-service=http
  8 firewall-cmd --reload			를 입력해주자
이것에 권한부여를 해준다. 
[root@server-1 test]# chmod -v a+x post_install.sh 		를 입력
mode of 'post_install.sh' changed from 0644 (rw-r--r--) to 0755 (rwxr-xr-x)

# 스트레스 부여
[root@server-1 test]# yum install epel-release.noarch 로 먼저 외부 소스를 받아온다.
[root@server-1 test]# yum install stress* -y		로 stress를 설치.

[root@server-1 ~]# find / -name *cpu*		로 *cpu*가 들어간 패키지를 추적한다.
[root@server-1 ~]# cat /proc/cpuinfo		
 

[root@server-1 ~]# top | head -8		를확인하면 CPU가 유휴상태인것을알수있다.
cpu에 부담을주기위해서는 -c, --cpu N 을 사용하라는 것이 --help에 등장한다.
Example: stress --cpu 8 --io 4 --vm 2 --vm-bytes 128M --timeout 10s   라는 예제가 있다.
cmd창을 새로열고 top를 입력, 왼쪽창에서는 stress 명령어를 사용해본다.

