4주차_금요일 메모

230915 			***tip) visualcode 다른폴더열기는 ctrl+O 를 누르기

오늘은 Dictionary 자료형에 대해 학습_java와도 관련

# 1. Dictionary 자료형 _ 'Key & Value'
1) Key의 특징					**tip)볼드체=ctrl + B
변하지 않는 값을 사용한다. 키 값에 list, set 불가, immutable (불변한) 객체 타입만이 가능
mutable한 변할수 있는 객체 타입인 list나 set 같은 타입은 키가 될 수 없다.
   - 키 값은 중복 될 수 없다.(unique, 유일무이)
동일한 키를 추가하면 나중에 추가된 키와 값에 기존의 키와 값이 덮어 띄워짐.
키 값은 고유해야하기 때문

2) Value의 특징
: 변하는 값과 변하지 않는 값 모두 사용할 수 있다.
Value에 리스트도 넣을 수 있다.
파이썬은 대응 관계를 나타낼 수 있는 자료형을 가지고 있다.
요즘 사용하는 대부분의 언어도 대응 관계를 나타내는 자료형을 갖고 있는데, 이를 연관
배열(Associative array) 또는 해시(Hash)라고 한다. >보통 해시값을 함수로 만들어서 사용.
~~~~~
# 중괄호를 사용하여 딕셔너리 생성
dict1 = {"usb16g": 1000, "usb32g": 2000, "usb64g": 3000}
# dict() 함수를 사용하여 딕셔너리 생성 = 우변의 결과가 좌변에 저장됨.
dict2 = dict(usb16g=1000, usb32g=2000, usb64g=3000)
# 리스트 내부에 키-값 쌍을 튜플로 묶어 딕셔너리 생성
dict3 = dict([("usb16g", 1000), ("usb32g", 2000), ("usb64g", 3000)])
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 1) 딕셔너리에 쌍 추가하기
# 빈 딕셔너리 생성
my_dict = {}
# 딕셔너리에 쌍 추가
my_dict['apple'] = 3
my_dict['banana'] = 2

print(my_dict)
#결과 = {'apple': 3, 'banana': 2}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 2) 딕셔너리에서 쌍 삭제하기
# 딕셔너리 생성
my_dict = {'apple': 3, 'banana': 2, 'cherry': 4}
# 딕셔너리에서 쌍 삭제
del my_dict['banana']

print(my_dict)
#결과 = {'apple': 3, 'cherry': 4}
==========================================================
# 2. SET(집합) 자료형
1)집합의 생성
# 중괄호를 사용하여 집합 생성
my_set1 = {1, 2, 3}
# set() 생성자를 사용하여 집합 생성
my_set2 = set([4, 5, 6])
###################################################################
2) 중복된 값 제거
my_set = {1, 2, 2, 3, 3, 3}
print(my_set)  # 출력: {1, 2, 3}
###################################################################
3) 요소의 추가 및 제거
my_set = {1, 2, 3}
# 요소 추가
my_set.add(4)
# 요소 제거
my_set.remove(2)

print(my_set)  # 출력: {1, 3, 4}
###################################################################
4) 집합의 연산
set1 = {1, 2, 3, 4}
set2 = {3, 4, 5, 6}
# 교집합 ( & )     s1 & s2
intersection = set1.intersection(set2)
# 합집합  ( | )      s1 | s2 
union = set1.union(set2)
# 차집합 ( - )       s1 - s2 
difference = set1.difference(set2)

print(intersection)  # 출력: {3, 4}
print(union)        # 출력: {1, 2, 3, 4, 5, 6}
print(difference)   # 출력: {1, 2}
###################################################################
5) 두 집합(s1, s2)이 아예 다른지(같은 요소가 없다)  >>질문 컨셉( 참/ 거짓)
s1.isdisjoint(s2) : 두 집합이 완전히 다른 집합이라는 것을 알고 싶을 때 사용
s1.issubnet(s2) : 부분 집합 관계를 확인하기 위해서 사용.
참고 : 대칭 차집합을 구하기 위해서는 symmetric_difference
또는 "^" 연산자를 이용한다.
~~~~~~~~~~~~~~~~~~~isdisjoint()~~~~~~~~~~~~~~~~~
set1 = {1, 2, 3}
set2 = {4, 5, 6}
set3 = {3, 6, 9}
# set1과 set2는 공통된 요소가 없으므로 True
is_disjoint1 = set1.isdisjoint(set2)
# set1과 set3는 공통된 요소인 3이 있으므로 False
is_disjoint2 = set1.isdisjoint(set3)

print(is_disjoint1)  # 출력: True
print(is_disjoint2)  # 출력: False
~~~~~~~~~~~~~~~~~~issubset()~~~~~~~~~~~~~~~~~~~~~~
set1 = {1, 2, 3, 4}
set2 = {1, 2}
# set2는 set1의 부분집합이므로 True
is_subset1 = set2.issubset(set1)
# set1은 set2의 부분집합이 아니므로 False
is_subset2 = set1.issubset(set2)

print(is_subset1)  # 출력: True
print(is_subset2)  # 출력: False
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
6) 집합 자료형 관련 함수들
add, update, remove, discard, pop, clear, in, len 등이 있다.
각각
print("<Set Examples>")
#set file example

#remove
set1={1,2,3,4,5}
print(set1)
set1.remove(4)
print(set1)

#pop (take one randomly erase)
s = {'r', 'a', 'n', 'd', 'o', 'm'}
print(f'집합 : {s}')
print(f'집합.pop() : { s.pop() }')
print(s)

#in 
s = {'a', 'b', 'c', 'd'}
if 'a' in s: print('집합 s 내부에 "a"가 존재')
else: print('집합 s 내부에 "a"가 존재하지 않음.')
if 'z' in s: print('집합 s 내부에 "z"가 존재')
else: print('집합 s 내부에 "z"가 존재하지 않음')

#len
s = {'e', 'f', 'g', 11, 12, 13}
print(f'집합 s : {s}')
s.clear()
print(f'clear 후 집합 : {s}')
print(len(s))

set1={1,2,3,4,5}
set2={}
print(len(set1))
print(len(set2))
===========================================================
02-8 자료형의 값을 저장하는 공간(변수) 파일 참조.
03-1 제어문 으로 넘어감

# 3. IF 제어문
if 문이 필요한 이유 - 1. 주어진 조건판단 2. 상황에 맞게 처리

조건문 (Conditional Statements):	tip: visualcode 들여쓰기= ctrl [ or ]
if: 조건이 참(True)인 경우에만 코드 블록을 실행합니다.
elif: 여러 개의 조건을 검사하고, 이전 조건이 거짓(False)일 때 실행합니다.
else: 모든 조건이 거짓일 때 실행합니다.

if 조건:
    # 조건이 참일 때 실행되는 코드
elif 다른_조건:
    # 다른 조건이 참일 때 실행되는 코드
else:
    # 모든 조건이 거짓일 때 실행되는 코드
----------------------------------------------------------------------------------------------
-등호 (Equality Operators):
x = 5
y = 10
result1 = (x == y)  # False, x와 y는 다르므로
result2 = (x != y)  # True, x와 y는 다르므로
-부등호 (Inequality Operators):
a = 7
b = 3
result3 = (a < b)   # False, a는 b보다 크지 않음
result4 = (a > b)   # True, a는 b보다 큼
result5 = (a <= b)  # False, a는 b보다 크지 않음
result6 = (a >= b)  # True, a는 b보다 크거나 같음
*** 리스트에서 멤버십 연산자 사용하기
fruits = ["apple", "banana", "cherry", "date"]
# "banana"이 fruits 리스트에 포함되어 있는지 검사
if "banana" in fruits:
    print("banana는 과일 목록에 있습니다.")

# "kiwi"가 fruits 리스트에 포함되어 있지 않은지 검사
if "kiwi" not in fruits:
    print("kiwi는 과일 목록에 없습니다.")

# 문자열에서 멤버십 연산자 사용하기
sentence = "Python programming is fun."

# "Python"이 문자열에 포함되어 있는지 검사 (대소문자 구분)
if "Python" in sentence:
    print("문자열에 'Python'이 포함되어 있습니다.")

# "Java"가 문자열에 포함되어 있지 않은지 검사
if "Java" not in sentence:
    print("문자열에 'Java'가 포함되어 있지 않습니다.")
~~~~~~~~~~~~~~~~~~~~~~~
ELIF 문 
jumsu =92
if jumsu >=90: print(jumsu,"는 A 학점 입니다")
elif jumsu >=80: print(jumsu,"는 B 학점 입니다")
elif jumsu >=70: print(jumsu,"는 C 학점 입니다")
elif jumsu >=60: print(jumsu,"는 D 학점 입니다")
else:
    print(jumsu, "는 F 학점 입니다")
===========================================================
python 3.10 이전 딕셔너리로 구현한 Switch Case 구현예제가 있다.
3.10 버전 이상부터 생긴것이 바로 Match case 문이다.
j = 85
mok = j // 10
match mok:
    case 10: print('A+')
    case 9: print('A0')
    case 8: print('B+')
    case 7: print('B0')
    case 6: print('C+')
    case _: print('F')
#결과: B+
==================================================
# 4. for 문 (feat. 구구단)
for 과 range함수는 바늘과 실의 관계이다.
파이썬 range 함수
 range 함수는 연속적인 숫자 객체를 만들어서 반환해주는 함수다.
 반복이 가능한 숫자형 iterable(반복 가능한) 객체를 반환해주는 함수다.
 range 함수는 반복문 for 와 함께 사용이 된다.
 range 로 만들어진 숫자의 객체가 리스트인 것 같지만 정확히는 range class형 객체다
~~~~~~~~~~~~~~~~~~~~~~~~
a = range(10)
print(a)
print(type(a))
for val in a:
    print(val)

for num in range(5):
    print(num)
>>0~4까지 숫자를 생성하고 출력

for odd in range(1, 11, 2):
    print(odd)
>>1~10까지의 홀수를 생성하고 출력

for num in range(10, 0, -1):
     print(num)
>>10에서 1까지 역순으로 숫자를 생성하고 출력하는 예제
~~~~~~~~~~~~~~~~~
**구구단을 짜는 for i in range 구문
for i in range(1, 10):  # 1부터 9까지의 숫자에 대해 반복
    print(f"{i}단")
    for j in range(1, 10):  # 1부터 9까지의 숫자에 대해 반복
        result = i * j
        print(f"{i} x {j} = {result}")
    print()  # 한 단 출력 후 줄바꿈
~~~~~~~~~~~~~~
**오류의 경우
for i in range(1, 10): 
    print(f"{i}단")
for j in range(1,10):
    result=i*j
    print(f"{i}x{j} = {result}")
print()
뭐가다른가? 싶지만, 두번째 코드에는 논리적 오류가 있다.
-바깥쪽 for 루프(for i in range(1, 10))는 1부터 9까지의 숫자를 반복하며, i 변수에 대입됩니다.
-그러나 안쪽 for 루프는 없으며, 대신 단순히 i와 j 변수를 사용하여 구구단을 계산하고 출력합니다.
-결과적으로 모든 i 값에 대해 1단의 구구단만 계산하고 출력
------------------------------------------------------------------------------------------------
# 5. While 문  _반복문 
조건이 '참'일동안만 반복한다.

예제1
treeHit = 0
while treeHit <= 10 : 
treeHit = treeHit +1 # treeHit += 1
print("나무를 %d 번 찍었습니다." % treeHit)
또는
print(f"나무를 {treeHit}번 찍었습니다.")
if treeHit == 10: print("나무 넘어갑니다.")
예제-2

cnt = 10
while cnt != 0:
print(f'{11 - cnt}회 실행')
cnt = cnt - 1

#####################################################################3 무한루프에 빠지지 않도록
user_input = ""  # 초기값 설정

while user_input != "exit":
    user_input = input("종료하려면 'exit'을 입력하세요: ")
    if user_input != "exit":
        print("프로그램이 종료되지 않았습니다.")

print("프로그램이 종료되었습니다.")
####################################################################
set1 = set("ABCDE")
print(set1)
while True:
    if len(set1) == 0: break
    p1 = set1.pop()
    print(f"{p1}를 꺼냈습니다")
    print(set1)
~~~~~~~~~~~~~~~~~~
set1 = set("ABCDE")
print(set1)
while True:
    if len(set1) == 0: 
        print("꺼낼게 없음")
        break
    else:
        p1 = set1.pop()
        print(f"{p1}를 꺼냈습니다")
        print(set1)
>>>없는데 pop이 자꾸 꺼내지않도록 필터링을 해준다.
